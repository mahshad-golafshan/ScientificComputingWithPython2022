# -*- coding: utf-8 -*-
"""04ex_numpy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GcNawGcGiXopHqZNfyJgALxwZnyCg9oj
"""

import numpy as np

"""#1-Reductions"""

m = np.arange(12).reshape((3,4))

m

"""mean of each column:"""

m.mean(0)

"""mean of each rows:"""

m.mean(1)

"""#2-Outer product"""

u = np.array([1, 3, 5, 7])
v = np.array([2, 4, 6, 8])

"""(1)outer in numpy:"""

np.outer(u,v)

"""(2)nested for:"""

l=[]
for i in u :
  l2=[]
  for j in v :
    l2.append(i*j)
  l.append(l2)
l

"""(3)numpy broadcasting operations"""

v*u.reshape(4,1)

"""#3-Matrix masking  """

import numpy.random as npr
npr.seed(123)
#a= npr.rand(6,10)
a=np.random.uniform(low=0.0,high=3.0,size=(6,10))
a

mask

mask = (a >= 0.3)   
for i in range(mask.shape[0]):
    for j in range(mask.shape[1]):
        if (mask[i,j]==False): a[i,j]=0
a

"""#4-Trigonometric functions"""

a= np.linspace(0,2*np.pi,100)
a

s=a[::10]
s

r=a[::-1]
r

abs=a[np.abs(np.sin(a)-np.cos(a)) <0.1]
abs

line, = plt.plot(a, np.sin(a), lw=2)
line, = plt.plot(a,np.cos(a) , lw=2)

"""#5-Matrices"""

u=np.arange(1,11)
v=np.arange(1,11)
a=v*u.reshape(10,1)
a

#a.trace()
s=sum([a[i][j] for i in range(10) for j in range(10) if i==j])
s

r=[a[i][j] for i in range(10) for j in range(10) if j==9-i]
r

rr=[a[i][j] for i in range(10) for j in range(10) if i==j+1]
rr

"""#6-Broadcasting"""

m=np.array([ 0, 198, 303, 736, 871, 1175, 1475, 1544, 1913, 2448])
r=m.reshape(1,10)
c=m.reshape(10,1)
s=np.array([np.abs(r-c)])
s

"""Kilometre = Miles / 0.62137  """

m=np.array([ 0, 198, 303, 736, 871, 1175, 1475, 1544, 1913, 2448])
r=m.reshape(1,10)
c=m.reshape(10,1)
s=np.array([(np.abs(r-c))/0.62137])
s

"""#7-Prime numbers sieve"""

import matplotlib.pyplot as plt
import numpy as np
import time
l=np.arange(0,99)
mask1=(l>1)  
k=99
for i in range(2,50):
    j=2
    while i*j<k:
        mask1[i*j]=False  
        j+=1
print(l[mask1]) 
N=500000   
step=25000
RunTime1=[]   
RunTime2=[]   
NumList=np.arange(99,N,step)
for n in range(99, N, step): 
    start= time.time()
    Num= np.arange(n)   
    mask=(Num>1) 
#normal
    for i in range(2,int(n/2)):  
        j=2                      
        while i*j<n:
           mask[i*j]=False 
           j+=1
    end=time.time()
    runtime=end-start
    RunTime1.append(runtime)
RunTime1=np.array(RunTime1)

"""Compute the prime numbers in the 0-N (start with N=99) range with a sieve (mask).

Constract a shape (N,) boolean array, which is the mask
Identify the multiples of each number starting from 2 and set accordingly the corresponding mask element
Apply the mask to obtain an array of ordered prime numbers
Check the performances (with timeit); how does it scale with N?
Implement the optimization suggested in the sieve of Eratosthenes

Eratosthenes function
"""

#start= time.time()
def SieveOfEratosthenes(num):
	prime = [True for i in range(num+1)]
	p = 2
	while (p * p <= num):
		if (prime[p] == True):
			for i in range(p * p, num+1, p):
				prime[i] = False
		p += 1
	for p in range(2, num+1):
		if prime[p]:
			print(p)
SieveOfEratosthenes(99)

# Commented out IPython magic to ensure Python compatibility.
def new_SieveOfEratosthenes(num):
    prime = np.array([True for i in range(num+1)])
    p = 2
    while (p * p <= num):
        if (prime[p] == True):
            for i in range(p * p, num+1, p):
                prime[i] = False
        p += 1
# %timeit [new_SieveOfEratosthenes(10)]

"""#8-Diffusion using random walk"""

def walk(walker,time):
  s=[]
  table=np.zeros((walker,time))
  for i in range(table.shape[0]):
    t=np.random.randint(-1,1,time)
    t[t==0]=1
    for j in range(t.shape[0]):
      table[i][j]=t[j]
  print(table)
  for i in range(table.shape[0]):
    s.append(table[i].s())
  return(s)

def mean(walker,time):
  mean=[]
  table=np.zeros((walker,time))
  for i in range(table.shape[0]):
    t=np.random.randint(-1,1,time)
    t[t==0]=1
    for j in range(t.shape[0]):
      table[i][j]=t[j]
  for i in range(table.shape[1]):
    mean.append(table[:,i].sum())
  return np.array(mean)/table.shape[0]