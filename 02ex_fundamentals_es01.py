# -*- coding: utf-8 -*-
"""02ex_fundamental_py.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Azze48j2nmJc53vB_yTvmwxi269vZcXb

# 1
"""

def f(alist):
    alist=[1,2,3,0,1,2,3,4]  
    return alist
alist = [1,2,3]
ans = f(alist)
print(ans)
print(alist)

"""#2 


"""

ans2=[x**2 for x in range(10) if x%2==1]
print(ans2)

"""#3"""

def filter(string,number):
    return [word for word in string if len(word) > number]

"""#4"""

lang = {"Python" : 3, "Java" : '', "Cplusplus" : 'test', "Php" : 0.7}
def ret(dic):
  return list(map(len, dic.keys()))
print(ret(lang))

"""#5"""

language_scores = [('Python', 97), ('Cplusplus', 81), ('Php', 45), ('Java', 32)]
language_scores.sort( key = lambda x : x[0] )
print(language_scores)

"""#6"""

def squ(x):
  return(x**2)
def cube(x):
  return(x**3)
def sixth(x):
  return(cube(squ(x)))

x=input()
print(sixth(int(x)))

"""#7"""

def Decorator(F):
    def wr():
        print("hello")
    return wr      
def squ(x): print("square:", x**2)
say_hello = Decorator(squ(8))
say_hello()

"""#8"""

def Fibonacci_rec(n):
	if n == 1:
		return 0
	elif n == 2:
		return 1
	else:
		return Fibonacci_rec(n-1)+Fibonacci_rec(n-2)
for i in range (1,21):
    print(Fibonacci_rec(i))

"""# 9"""

def Fibonacci_rec(n):
	if n == 1:
		return 0
	elif n == 2:
		return 1
	else:
		return Fibonacci_rec(n-1)+Fibonacci_rec(n-2)
for i in range (1,21):
    print(Fibonacci_rec(i))

# Commented out IPython magic to ensure Python compatibility.
# %timeit Fibonacci_rec(20)

def fib_loop(n):
    a = 0
    b = 1
    if n == 0:
        return a
    elif n == 1:
        return b
    else:
        for i in range(2, n):
            c = a + b
            a = b
            b = c
        return b
print(0)
for i in range (2,21):
    print(fib_loop(i))

# Commented out IPython magic to ensure Python compatibility.
# %timeit fib_loop(20)

"""-Iteration is faster and more efficient than recursion.
-It's easier to optimize iterative codes, and they generally have polynomial time complexity.
Itâ€™s easier to code the solution using recursion when the solution of the current problem is dependent on the solution of smaller similar problems: fibonacci(n) = fibonacci(n-1) + fibonacci(n-2)

iteration used to repeatedly execute statements without overhead and without using stack memory.

#10
"""

class Polygon:
  def __init__(self, input_tuple = (0,0,0)):
    self.input_tuple = input_tuple

  def length_updater(self, index, length):
    input_list = list(self.input_tuple)
    input_list[index] = length
    self.input_tuple = tuple(input_list)
    print("updated!")

  def length_getter(self, index):
    return self.input_tuple[index]

  def perimeter(self):
    return print("the perimeter is ", sum(self.input_tuple))

  def getOrderedSides(self, increasing = True):
    return tuple(sorted(self.input_tuple, reverse = bool(1 - increasing)))

triangle = Polygon((4,5,6))

triangle.length_getter(0)

triangle.length_updater(0,8)

triangle.perimeter()

triangle.getOrderedSides(False)

"""#11"""

class rectangle(polygon):
  def __init__(self,ti):
    self.ti=ti
    self.len=len(ti)
  def area(self):
      p=self.ti[1]*self.len
      print(p)

a=rectangle(ti=(2,1,1,1))
a.area()