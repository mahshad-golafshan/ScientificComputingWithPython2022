# -*- coding: utf-8 -*-
"""11ex_montecarlo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ySGy1uhZeLjJVO7vaKxunGeRAv5oqvOT

# 1
"""

import numpy as np
import matplotlib.pyplot as plt
import numpy.random as npr
from scipy import integrate
import math

npr.seed(2344)

def Decay_prob(t):
    return 1- 2**(-t/theta)
Thall_Nu= 1000  
Lead_Nu= 0     
T=100
theta= 3.052* 60
Thall_Nu_list=[]
Lead_Nu_list=[]
for t in range(T):
    Thall_Nu_list.append(Thall_Nu)
    Lead_Nu_list.append(Lead_Nu)
    for i in range(Thall_Nu):
        temp = npr.rand()
        if temp< Decay_prob(t):
            Thall_Nu -=1
            Lead_Nu +=1
Time_List=[t for t in range(T)]
fig, (ax1,ax2,ax3) = plt.subplots(3, 1, figsize=(10, 15))
ax1.scatter(Time_List, Thall_Nu_list, label= 'Thallium')
ax1.scatter(Time_List, Lead_Nu_list, label= 'Lead')
def t_inverse_fun(z):
    return math.log2(z*np.log(2))   
t_list = np.abs(np.array([t_inverse_fun(npr.rand()) for i in range(1000)]))
P, edges,_= ax2.hist(t_list, bins='auto', color= 'black')
ax2.set_ylabel("P(t)")
ax2.set_xlabel("t") 
bin_centers = 0.5 * (edges[:-1] + edges[1:])
N_remained_per_t=[]
N_remained=1000
for k in range(len(list(bin_centers))):
    N_remained_per_t.append(N_remained)
    N_remained-= P[k]
Time_List=[i for i in range(len(list(bin_centers)))]
ax3.scatter(Time_List, N_remained_per_t, color= 'r', marker = '*')

"""# 2"""

from scipy import integrate
def f(x):
    return np.sin(1/(x*(2-x)))**2
N=1000
inside_dots= 0 
for i in range(N):
    y_rand= npr.rand()
    x_rand= npr.uniform(0,2)
    if y_rand < f(x_rand): inside_dots += 1
Integral = (inside_dots/N) * (2*1)
result = integrate.quad(f, 0, 2)
print("Hit and Miss".format(N,  np.abs(1- Integral/result[0])))
sum=0
for i in range(N): 
    x_rand = npr.uniform(0,2)
    sum += f(x_rand)
Integral= (2-0) * sum/N
print("Mean Value error".format(N,  np.abs(1- Integral/result[0])))

"""# 3"""

import numpy as np
import matplotlib.pyplot as plt
import numpy as np
def f(x_arr):
    return np.sum(np.power(x_arr, 2)) - 1
dim = 10
N = 100000
count = 0
for i in range(N):
    x_arr = np.random.random(dim) * 2 - 1
    if f(x_arr) <= 0 : count += 1
I = count / N * (2**dim)
print("Integral:", I)
#print("Exact integral: {:.5f}".format(4/3*np.pi))

def f(x_arr):
    return np.sum(np.power(x_arr, 2)) - 1

I = []
for dim in np.arange(9) + 2:
    N = 100000
    count = 0
    for i in range(N):
        x_arr = np.random.random(dim) * 2 - 1
        if f(x_arr) <= 0 : count += 1
    I.append(count / N * (2**dim))
    
plt.plot(np.arange(9) + 2, I)

"""# 4"""

def f(x):
    return x**(-0.5)/(np.exp(x) + 1)
def w(x):
    return 1/(np.sqrt(x))
N=1000
result = integrate.quad(w, 0, 1)
w_integral = result[0]
sum=0
for i in range(N):
    x_rand = npr.uniform(0,1)
    sum+= f(x_rand)/w(x_rand)
result1 = integrate.quad(f, 0, 1)
Integral = (1/N)* sum *w_integral
#print(" integral: 0.84")
print( Integral)